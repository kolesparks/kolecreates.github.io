<!doctype html>
<html lang="en">
    <head>
        <title>Kole Sparks</title>
        <meta name="description" content="Fullstack consultant and solo builder." />
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link rel="icon" href="/favicon.ico" />
        <style>
            html {
                width: 100%;
                height: 100%;
                max-width: 100%;
                max-height: 100%;
                overflow: hidden;
            }
            body {
                display: grid;
                grid-template-columns: 10% 80% 10%;
                grid-template-rows: 5em 1fr 3em;
                font-family: Arial, sans-serif;
                line-height: 1.6;
                margin: 0;
                height: 100%;
                width: 100%;
                max-height: 100%;
                max-width: 100%;
                overflow-x: hidden;
                overflow-y: auto;
            }

            header {
                grid-column-start: 1;
                grid-column-end: 4;
                grid-row-start: 1;
                grid-row-end: 2;
                padding: 1em;
                width: 100%;
                text-align: center;
                display: flex;
                flex-direction: row;
                justify-content: center;
                align-items: center;
            }

            header img {
                width: 50px;
                height: 50px;
                border-radius: 50%;
                margin-right: 10px;
            }

            main {
                display: flex;
                flex-direction: column;
                align-items: center;
                grid-column-start: 2;
                grid-column-end: 3;
                grid-row-start: 2;
                grid-row-end: 3;
                padding: 1em;
                max-width: 100%;
            }

            section {
                width: 100%;
            }

            nav {
                width: 100%;
                overflow: hidden;
                padding: 0;
            }

            nav h4 {
                margin-top: 0.5em;
                margin-bottom: 0.5em;
            }

            nav ol {
                list-style-type: none;
                display: flex;
                flex-direction: row;
                gap: 1em;
                flex-wrap: nowrap;
                width: 100%;
                overflow-x: scroll;
                padding: 0;
                height: 60px;
                align-items: center;
                 margin-top: 0.5em;
                margin-bottom: 0.5em;
            }

            nav ol li {
                display: inline-block;
            }

            nav ol li a {
                text-decoration: none;
                color: #000;
                padding: 0.5em;
                border-radius: 0.5em;
                background-color: #00000011;
                white-space: nowrap;
                margin-bottom: 1em;
            }

            article {
                width: 100%;
            }

            article h2 {
                line-height: 1em;
            }

            article h2 + p {
                color: #000;
                opacity: 0.54;
                font-size: 1em;
            }

            article a {
                word-wrap: break-word;
            }

            hr {
                border-top: 2px dotted #000;
                width: 20em;
                margin-top: 1em;
                margin-bottom: 1em;
                opacity: 0.28;
            }

            hr + a {
                color: #000;
                opacity: 0.54;
            }

            footer {
                grid-column-start: 1;
                grid-column-end: 4;
                grid-row-start: 3;
                grid-row-end: 4;
                background-color: #f8f8f8;
                text-align: center;
            }
        </style>
    </head>
    <body>
        <header>
            <img src="./kole-headshot.jpeg" alt="headshot of Kole Sparks"/>
            <h1 id="top">Kole Sparks</h1>
        </header>
        <main>
            <section>
                <h2>About Me</h2>
                <p>
                    7 years fullstack dev. Ex-Amazon SDE2. Lead engineer on an ERP system for an <a href="https://villagecaregiving.com" target="_blank">in-home care company</a>. Solo building with Bun, sqlite, vanilla html/css/js - running on <a href="https://railway.com?referralCode=ABSfL6" target="_blank">Railway</a>. 
                </p>
                <p>
                    My work is dedicated to Anna, Owen, Moose, Bunga, fam, and all those who came before me.
                </p>
            </section>

            <nav>
                <h4>
                    Projects
                </h4>

                <ol>
                    <li>
                        <a href="https://wwww.headlinefilter.com" target="_blank" rel="noopener">
                            Headline Filter
                        </a> 
                    </li>
                    <li>
                        <a href="https://wwww.beveragewall.com" target="_blank" rel="noopener">
                            Beverage Wall
                        </a>
                    </li>
                    <li>
                        <a href="https://github.com/kolesparks/kolecreates.github.io" target="_blank" rel="noopener">
                            kolesparks.com
                        </a>
                    </li>
                </ol>
            </nav>

            <nav>
                
                <h4>
                    Posts ➡️
                </h4>
                <ol>
                    <li>
                        <a href="#beverage-wall-release">
                            Beverage Wall Release
                        </a>
                    </li>
                    <li>
                        <a href="#swarm-coding-does-not-work">
                            Swarm Coding Does Not Work
                        </a>
                    </li>
                    <li>
                        <a href="#headline-filter-release">
                            Headline Filter Release
                        </a>
                    </li>
                    <li>
                        <a href="#prisma-is-the-repository-layer">Prisma is the Repository Layer</a>
                    </li>
                    <li>
                        <a href="#llm-coding-break">Taking a break from LLM coding</a>
                    </li>
                     <li>
                        <a href="#race-to-the-bottom">Race to the Bottom</a>
                    </li>
                    <li>
                        <a href="#future-of-platform-engineering">Future of Platform Engineering</a>
                    </li>
                    <li>
                        <a
                            href="#minimal-systems"
                            onmousedown="window.location.href='/#minimal-systems'"
                        >
                            Minimal Systems
                        </a>
                    </li>
                     
                    <li>
                        <a href="#kiro-ide">Kiro IDE</a>
                    </li>
                    <li>
                        <a href="#prolog-dabble">Prolog Dabble</a>
                    </li>
                    <li>
                        <a href="#ai-conjectures">A few AI Conjectures</a>
                    </li>
                    <li>
                        <a href="#json-columns-are-tech-debt"
                            >JSON Columns are Tech Debt</a
                        >
                    </li>
                    <li>
                        <a href="#single-file-site">Single File Site</a>
                    </li>
                    <li>
                        <a href="#software-patents">Software Patents</a>
                    </li>
                    <li>
                        <a href="#universal-economic-value"
                            >Universal Economic Value</a
                        >
                    </li>
                    <li>
                        <a href="#open-knowledge-engine"
                            >Open Knowledge Engine</a
                        >
                    </li>
                    <li>
                        <a href="#cellular-agriculture">Cellular Agriculture</a>
                    </li>
                    <li>
                        <a href="#k">K</a>
                    </li>
                    <li>
                        <a href="#jsolite">jsolite</a>
                    </li>
                    <li>
                        <a href="#tcp-relay-server">TCP Relay Server</a>
                    </li>
                    <li>
                        <a href="#s3-database">S3 as a Database</a>
                    </li>
                    <li>
                        <a href="#thought-diet">Thought Diet</a>
                    </li>
                </ol>
            </nav>


            <article id="beverage-wall-release">
                <h2>Beverage Wall Release</h2>
                <p>Posted Feb 8th, 2026</p>

                <p>
                    This last week I released another small site <a href="https://wwww.beveragewall.com" target="_blank" rel="noopener">Beverage Wall</a>. 
                    The site is just pictures of beverages uploaded by random people. You can post your own for free without a login.
                    It is written in vanilla html/css/js on the frontend, Bun+Sqlite on the backend. Uses a small model from openrouter to ensure only beverage images are uploaded.
                    imagemagick is used to process uploaded images. Images are streamed down with the html as embedded bas64 urls for the fastest time-to-first-beverage. 
                    Images are compressed client-side before upload to reduce upload time.
                    Open Source on<a href="https://github.com/kolesparks/beveragewall" target="_blank" rel="noopener">Github</a>. Hosted on <a href="https://railway.com?referralCode=ABSfL6" target="_blank">Railway</a>.
                </p>
            </article>


            <article id="swarm-coding-does-not-work">
                <h2>Swarm Coding Does Not Work</h2>
                <p>Posted Jan 24th, 2026</p>

                <p>
                    Cursor recently published a blog post detailing their <a href="https://cursor.com/blog/scaling-agents" target="blank">scaling of long-running autonomous coding</a>. 
                    They are running upwards of 2,000 agents in parallel to build classically hard to build software. 
                    Their projects include a browser, Excel clone, Windows 7 emulator, and Java LSP Server. 
                    These agentic loops have generated millions of lines of code across tens of thousands of commits over the span of weeks. 
                    Research like this is valuable to the engineering community regardless of what the future of software looks like. 
                    We get emperical evidence on how agentic coding scales. Evidence that may help prove it worthy or unworthy of humanity's attention.
                    All that beings said, I am skeptical. My hunch is that agentic coding does not scale in a meaningful way and will never scale assuming the foundation model architectures remain relatively static.
                    <ol>
                        <li>
                          Cursor's projects (Excel, Browser, etc.) are all building against full specifications of software that already exists. 
                    Having a crystal clear battle-tested specification of what to build is massive advantage and one that virtually does not exist in the real software market. Not to mention, the foundational models are trained on existing code, some of which is the source code of the things that Cursor is rebuilding.
                    Yes, there is a market for rebuilding existing software, but the rebuild has to be different in some fundamental way in order to be valuable, and that makes things much harder than simply cloning the original. Lastly, these projects use a significant number of third-party libraries - some of which are non-trivial to replace - so the software is not even close to 'from-scratch'.
                        </li>
                        <li>
                           None of the research projects have reached production-grade status. This is more important than many think. How do we know it's possible? How do we know the total cost/time? We cannot determine the real-world production-grade time and resource costs by extrapolation. Getting software to production-grade (100% done) is generally disproportionately more expensive than getting it to 20%, 40%, 70%, 90%. 
                        </li>
                         <li>
                           We already know how scaling software development goes. We have Amdahl's law, Brook's law, Conway's law - and plenty of research by big tech companies. Yes, you can scale to thousands of developers, but you do make trade-offs, and there is work that cannot be parallelized.
                        </li>
                        <li>
                            What about $$$? I wasn't able to find numbers from Cursor. But they did say they are using recent models like Opus 4.5 and GPT 5.2. I can attempt to approximate. 
                            First, we need to approximate usage. To do so, I'll use Claude Code w/ Max subscription as the reference point because I have experience with it and so do many devs. Max Subscription usage is complicated, changing, and inconsistent across users. 
                            So I'll be generous and say you can get usage equivalent to 10 parallel claude code sessions 24/hr per day on Max x20 plan. 
                            Now, for estimating pricing, we need to use API pricing, not subscription pricing, because with 2000 agents you would definitely axhuast a single subscription and TOS says you can't exploit multiple subs/account share. So we have to use API pricing.
                            A recent <a href="https://www.reddit.com/r/ClaudeAI/comments/1qfosa6/did_the_math_on_claude_code_pricing_how_are_other/" target="_blank" rel="noreferrer">Reddit Post</a> gives an estimate for how much it would cost in API pricing to use Claude Code as much as you can on the Max x20 Plan. 
                            It is in the range of a few thousand dollars. Let's be generous and say you get $1000 worth of API usage.
                            In summary, for $1000/month in API spend, you get 10 agents, 24/hr per day. 2,000 agents = $200,000/month. This number is so shocking I feel that I must be missing something.
                            The promise of swarm-coding is that it can deliver software so much faster. 
                            The promise is, yes, you could hire a world-class human team for $200k/month, but they'd take years, and the swarm will take a month.
                            The promise hinges on production-grade delivery - which remains to be seen.
                        </li>
                    </ol>

                    Even from a pure theoretic perspective, I find the swarm-coding endevour peculiar. It feels like we're not learning from the past and ignoring the true capability of the computing power we have. What is much more promising is the research by Google and others into combining LLMs with formal methods to search massive solution spaces. 
                    To me, this is a more rigorous way of using compute. Cursor's work feels like watching a bunch of monkeys type on a keyboard - hoping a perfect copy of the linux kernal will appear.
                </p>
            </article>

            <article id="headline-filter-release">
                <h2>Headline Filter Release</h2>
                <p>Posted Jan 24th, 2026</p>
                <p>
                    My latest project <a href="https://www.headlinefilter.com" target="_blank">Headline Filter</a> sifts through news headlines to find the ones you ask for. 
                    You see only what you want to see. No algorithm. No ads. No trackers. No unsolicited content to distract you. Simple and free.
                    Coded by hand using Bun, vanilla html/css/js. Http streaming for real-time results. Gemma 3n 4b model for super fast and efficient inference. <a href="https://scrapingfish.com/" target="_blank" >Scrapingfish</a> for ethical and simple scraping + novel technique to scrape and decode links in one request.
                    Open source on <a href="https://github.com/kolesparks/headlinefilter" target="_blank"> GitHub</a> under the <a href="https://world.hey.com/dhh/the-o-saasy-license-336c5c8f" target="_blank">O Saasy License</a> and hosted on <a href="https://railway.com?referralCode=ABSfL6" target="_blank">Railway</a>.
                </p>
            </article>

            <article id="prisma-is-the-repository-layer">
                <h2>Prisma is the Repository Layer</h2>
                <p>Posted Jan 22nd, 2026</p>

                <p>
                    There are codebases that implement repository interfaces that wrap <a href="https://prisma.io/orm" target="_blank">Prisma ORM</a>. There are articles that promote this pattern. I think it is an anti-pattern. 
                    Prisma is already a typescript-first abstraction over your database. Wrapping method calls in your own interface is over-abstraction. The method called and the arguments passed to it are almost always directly relevant to the surrounding logic.  
                    By wrapping the prisma logic in a function, you are hiding domain logic, not incidental information. You try to name your repository methods clearly but inevitably fail to capture the behavior precisely. 
                    You will end up writing hundreds of specialized repository methods or worse just reuse an existing method that only half meets your needs or selects more data than necessary because you're lazy. What about really complex stuff and code reuse? I'm not saying you can't ever declare prisma logic in a separate function. Just handle modularity how you do anywhere else. 
                    And remember Prisma has Client Extensions which let you add custom methods to the client - this is much more elegant than creating your own interface layer ontop - or tucking them away in some lib or utils file that future devs/you won't find. 
                    What about testability? This has no influence. Regardless of patterns, be extremely cautious of mocking the database, as it can give you false confidence and is extra test infrastructure to maintain. 
                    Just use @testcontainers or sqlite db. What if we decide to switch our ORM? 1. The amount of refactoring is equivalent in large code bases due to the number of specialized methods you end up with when using the repository pattern
                    2. you can rather easily implement a shim for the prisma client that is backed by whatever library you want. heck, write some tests and ask claude code to build you one.
                </p>
            </article>

            <article id="llm-coding-break">
                <h2>Taking a break from LLM Coding</h2>
                <p>Posted Jan 15th, 2026</p>

                <p>
                    Since 2023, or whenever GPT-3 was released, I've pushed LLMs to their limit for automating software development.
                    <br/>

                    Despite the improvement of LLMs for coding, and despite the countless hours and dollars spent, I am still unsure of them. They are so much better than they were - by a light year. 
                    But that isn't the problem. The problem is what happens to me over time. Even after a few days of heavy LLM usage - I feel the atrophy. 
                    The atrophy of every skill. Not just the low-level coding skills, but the high level design and architecture skills, too. 
                    Many people are saying that the new valuable skills for a human dev to have are now architecture and design among other things. 
                    But I feel that these high-level skills waste away too - just maybe more slowly or less obviously. This means the whole "AI-Orchestrator" job is self-defeating - you will get worse at your job over time - not better.
                    That is my theory anyway and that is how I feel in a literal sense after pushing "AI-Orchestrator" to the limit for years. So I am taking a break, a few weeks, a month, idk, to really focus on my skills. I will still use LLMs for deep-research and code reviews - maybe. 
                    But I'll be writing every line of code and thinking through problems almost entirely by myself.
                </p>

            </article>

            <article id="race-to-the-bottom">
                <h2>The Race to the Bottom</h2>
                <p>Posted Jan 5th, 2026</p>
                <p>
                    The race to the top of the abstraction stack is a race to the bottom of the market.
                    <br/>
                    Easy tech attracts more devs and more devs means more competition.
                    <br/>
                    Easy tech is abstraction and abstraction is specialization. Specialization has a narrow market. Narrow market means fewer buyers to compete over.
                    <br/>
                    LLM coding accelerates this. LLM coding lets more people build stuff with easy tech. And fast. 
                    <br/>
                    More stuff. More people. Fast. This is a race to the bottom.
                    <br/>
                    My advise: get out of the race - almost everyone will be a loser.
                </p>

            </article>

            <hr />
            <a href="#top">back to top</a>

            <article id="future-of-platform-engineering">
                <h2>Draft: The Future of Platform Engineering</h2>
                <p>Posted Oct 26th, 2025</p>


                <h3>Current SOTA Platform Engineering</h3>

                <ul>
                    <li>
                        <a href="https://vercel.com/fluid"  target="_blank">Vercel Fluid Compute</a>
                    </li>
                    <li>
                        <a href="https://useworkflow.dev/" target="_blank">Workflow DevKit by Vercel</a>
                    </li>
                     <li>
                        <a href="https://railway.com/" target="_blank">Railway</a>
                    </li>
                     <li>
                        <a href="https://www.shuttle.dev/" target="_blank">Shuttle</a>
                    </li>
                     <li>
                        <a href="https://trigger.dev/" target="_blank">Trigger.job</a>
                    </li>
                    <li>
                        <a href="https://blog.cloudflare.com/capnweb-javascript-rpc-library/" target="_blank">Cap'n Web RPC by Cloudflare</a>
                    </li>
                </ul>
            </article>

            <hr />
            <a href="#top">back to top</a>

            <article id="minimal-systems">
                <h2>Minimal Systems</h2>
                <p>Posted Aug 17th, 2025</p>

                <ul>
                    <li>
                        How complicated, robust, performant, scalable can a
                        system be that is created with a minimal toolset?
                    </li>
                    <li>
                        How minimal can the toolset of a complicated, robust,
                        performant, scalable system be?
                    </li>
                </ul>
            </article>

            <hr />
            <a href="#top">back to top</a>

            <article id="kiro-ide">
                <h2>Kiro IDE</h2>
                <p>Posted Aug 14th, 2025</p>
                <p>Updated Aug 17th, 2025</p>

                <p>
                    A download code hit my inbox the other day for the new
                    AWS-backed Kiro AI IDE.
                </p>

                <p>
                    The Kiro AI IDE boasts "spec-driven development" as its
                    unique take on AI assisted coding. This had me excited
                    initially. I have advocated for something like spec-driven
                    development for years - before vibe coding was coined a
                    term.
                </p>

                <p>
                    After a couple hours of using it to build a complex
                    enterprise-grade home health agency management system / EHR
                    system, I conclude the following:
                </p>

                <ul>
                    <li>
                        Spec files need to be divided up, based on feature or
                        other sensible organization principle, and it appears
                        Kiro does not provide any guidance to the developer or
                        agent to do this well. The agent was happy to try to fit
                        all the requirements and design for the entire
                        enterprise system in a single spec file. Sure, I as the
                        developer could have steered the agent to do this, but I
                        should not have to just know, and to know how, to do
                        that in an IDE built for such a development methodology.
                    </li>
                    <li>
                        There is no rich-link between "task" and requirement,
                        only text, and the IDE doesn't, to my knowledge, connect
                        these two in a rich way. And it certainly doesn't
                        connect in the other direction (requirement to task).
                    </li>
                    <li>
                        Tests seem to be an afterthought. I had to remind the
                        agent to write test a few times. and there is not rich
                        link between tests and requirements in the spec.
                    </li>
                    <li>
                        Test quality is low. The agent wrote extremely brittle,
                        implementation dependent tests - trying to write unit
                        tests for modules that clearly warrant integration or
                        end to end tests.
                    </li>
                </ul>

                <p>
                    Overall, Kiro, at this early stage, provides very little
                    structure over the typical AI assisted coding workflow
                    established by other tools like Cursor, Copilot, Claude
                    Code. It needs to be more structured, more streamlined,
                    otherwise it feels like a weird middleground that is not
                    better than vibe coding.
                </p>

                <p>
                    P.S. A few folks have developed workflows with other tools
                    that are inspired by Kiro/spec-driven development. This is
                    my recommendation for any AI coders. Fork one of these
                    workflows or create your own that is agnostic to any
                    specific AI coding brand. You really dont want to be locked
                    into a specific tool right now.
                </p>
            </article>

            <hr />
            <a href="#top">back to top</a>

            <article id="prolog-dabble">
                <h2>Prolog Dabble</h2>
                <p>Posted Aug 14th, 2025</p>

                <p>
                    I recently went down the rabbit hole of learning Prolog, one
                    of the original logic programming languages. In simple
                    terms, Prolog allows you to define a knowledge base of facts
                    and rules, then query the knowledge base to ask questions or
                    find solutions that satisfy all the constraints.
                </p>

                <p>
                    I've yet to find a real use-case for Prolog in my line of
                    work. Though, I will keep it as a tool in my toolbox,
                    because I have a gut feeling it will be useful one day. Or
                    at least, the understanding of logic programming will be
                    useful.
                </p>

                <p>
                    Additionally, I hypothesized that an LLM could produce
                    Prolog facts, rules, and queries in two useful ways. 1.
                    simply dumping its internal knowledge into Prolog knowledge
                    2. translating ambiguous, fuzzy human language into
                    unambiguous, precise Prolog. I found that LLMs are no more
                    capable of doing this for Prolog than other programming
                    languages or formalisms. Also, LLMs suffer from context
                    windows and context rot which limits the size of the Prolog
                    knowledge base it can reason over - akin to codebases scale
                    issues in other languages. Lastly, trust in LLM output
                    remains low, and that undermines the guarantees Prolog has
                    to offer.
                </p>
            </article>

            <hr />
            <a href="#top">back to top</a>

            <article id="ai-conjectures">
                <h2>A Few AI Conjectures</h2>
                <p>Posted May 7th, 2025. Updated August 14th, 2025</p>

                <p>
                    Three back of the napkin statements that I believe hold true
                    about artificial intelligence:
                </p>

                <ul>
                    <li>Autonomy is more valuable than intelligence.</li>
                    <li>
                        There is no substitute for the type of intelligence that
                        emerges from biological brains.
                    </li>
                    <li>
                        As long as a human mind is needed, it is beneficial for
                        the human mind to be intelligent. Once it is not
                        beneficial for the human mind to be intelligent, the
                        human mind is not needed.
                    </li>
                </ul>
            </article>

            <hr />
            <a href="#top">back to top</a>

            <article id="json-columns-are-tech-debt">
                <h2>JSON Columns are Technical Debt</h2>
                <p>Posted May 5th, 2025</p>

                <p>
                    On many occasions i've stuffed data into a json column
                    instead of a proper normalized schema.
                </p>

                <p>
                    Most of the time, i'm just trying to implement something
                    fast, for one reason or another. Rarely is there a true
                    technical justification.
                </p>

                <p>However, there are good use cases for json columns:</p>
                <ul>
                    <li>truly unstructured data</li>
                    <li>
                        when the number of fields exceeds or approaches the
                        databases column limit
                    </li>
                </ul>

                <p>
                    There could be more, but the above are the reasons i've
                    encountered.
                </p>
            </article>

            <hr />
            <a href="#top">back to top</a>

            <article id="single-file-site">
                <h2>Single File Site</h2>
                <p>Posted May 4, 2025</p>

                <p>
                    My blog was previously a multi-page blog statically
                    generated using my
                    <a href="https://www.npmjs.com/package/minssg"
                        >Minimum Static Site Generator (minssg)</a
                    >. 5-20s from commit to published. Yet, that's not simple
                    enough for me. Still needed the Bun runtime, a Github
                    Action, template syntax, etc.
                </p>

                <p>Introducing, single file site:</p>
                <ul>
                    <li>1 file, 1 page</li>
                    <li>no class names</li>
                    <li>no separate css files</li>
                    <li>no separate js files</li>
                    <li>no build</li>
                </ul>

                <p>and a couple other things about this new site:</p>
                <ul>
                    <li>
                        no LLM. hand typing and googling things like the old
                        days still has huge value. might write a post about this
                        topic.
                    </li>
                    <li>html semantics, plain css, js only when necessary</li>
                </ul>

                <p>
                    I suspect I could have 100s of blog posts on this page
                    before noticing any latency. And with modern HTTP streaming,
                    I might not even notice the latency because the first few
                    posts load instantly and the rest stream in below the
                    viewport.
                </p>

                <p>
                    This desire for ultra minimalism is catalyzed by my day job
                    experience where it takes 10m to deploy the simplest
                    frontend update. THOUSANDS of indirect dependencies, npm
                    vulnerability warnings, constant breaking changes, bugs
                    unfixed for years, abstraction lock-in, etc.
                </p>
            </article>

            <hr />
            <a href="#top">back to top</a>

            <article id="software-patents">
                <h2>Software Patents</h2>
                <p>Posted Aug 22, 2024</p>

                <p>Good, Bad, or Ugly</p>

                <p>
                    Recently came across a software company with over a dozen
                    patent numbers listed at the bottom of their website. In
                    looking at a few I noticed a pattern.
                </p>

                <p>
                    The patent filing includes a beefy PDF specification thats
                    around 40 pages long. The core idea is usually captured by
                    the abstract and perhaps a single diagram. The rest of the
                    PDF is filled in with many different use case examples,
                    variations of the same diagram, and pages of text explaining
                    each diagram.
                </p>

                <p>
                    Most importantly I noticed that the core idea is very
                    high-level. The specification is NOT nearly enough
                    instruction to develop the actual thing. It takes
                    considerable time and technical effort to take one of these
                    ideas and create an actual working system.
                </p>

                <p>So i'm left wondering:</p>

                <ul>
                    <li>
                        <p>
                            Do these patents exist to protect ideas that would
                            otherwise be too easy to "steal" or re-invent
                            independently?
                        </p>
                    </li>
                    <li>
                        <p>
                            Is the idea worth more than the implementation?
                            Perhaps, but implementation is hard, and there's
                            almost always multiple ways of doing it, each way
                            with pros and cons over others. There's so much room
                            for competition just within implementation of the
                            same idea.
                        </p>
                    </li>
                    <li>
                        <p>
                            If I were to build a system similar to the one
                            described in one of these patents - where is the
                            line of infringement? What can be similar and what
                            must be different?
                        </p>
                    </li>
                </ul>
            </article>

            <hr />
            <a href="#top">back to top</a>

            <article id="universal-economic-value">
                <h2>Universal Economic Value</h2>

                <p>Posted on August 17th, 2024</p>

                <p>Solve puzzles - make money.</p>

                <p>
                    I discover the
                    <a href="https://arcprize.org/play" target="_blank"
                        >ARC-AGI challenge</a
                    >
                    a couple months ago.
                </p>
                <p>
                    It is a challenging series of puzzles with human scores
                    around 80% while the state-of-the-art algorithm has achieved
                    only 43% as of August 2024.
                </p>

                <blockquote>
                    ARC-AGI is explicitly designed to compare artificial
                    intelligence with human intelligence. To do this, ARC-AGI
                    explicitly lists the priors knowledge human have to provide
                    a fair ground for comparing AI systems. These core knowledge
                    priors are ones that humans naturally possess, even in
                    childhood. ... ARC-AGI avoids a reliance on any information
                    that isn’t part of these priors, for example acquired or
                    cultural knowledge, like language.
                </blockquote>
                <p>
                    —
                    <cite
                        ><a href="https://arcprize.org/arc" target="_blank"
                            >https://arcprize.org/arc</a
                        ></cite
                    >
                </p>

                <p>
                    Discovering ARC-AGI reminded me of a thought experiment I
                    was obsessed with a few years ago. An idea of "Universl
                    Econimic Value".
                </p>

                <p>
                    Adjacent to universal basic income (UBI), UEV is where there
                    is some way to capitilize on the basic value of human
                    intelligence to give everyone some baseline economic worth.
                </p>

                <p>
                    Physical labor is UEV historically, but we observe how wages
                    stagnate while costs explode, and we also observe how labor,
                    of all types, becomes automated overtime.
                </p>

                <p>
                    ARC-AGI rekindled the idea by demonstrating there is still
                    some fundamental disparity between human and machine
                    intelligence.
                </p>

                <p>
                    What if any human could earn a wage by completing small
                    cognitive tasks within a larger information system.
                    Similarly to how car manufacturing pipelines work - where
                    there are big complicated machines doing large portions -
                    alongside humans doing smaller more intricate segments.
                </p>
            </article>

            <hr />
            <a href="#top">back to top</a>

            <article id="open-knowledge-engine">
                <h2>Open Knowledge Engine</h2>
                <p>Posted on August 13, 2024</p>

                <p>
                    Like wikipedia but queryable, highly structured,
                    programatically interactive.
                </p>
                <p>
                    Like Wolfram Language but open source, open data, and a
                    simpler interface.
                </p>

                <p>
                    The schema of this database and query interface must be
                    intuitive, and grow at a significantly slower rate than the
                    data. If the schema and interface grow in complexity equal
                    to the data - then it adds litte to no value. I'm not sure
                    if it's possible to find a schema and interface that are
                    static. I have to imagine at least in the beginning, as data
                    is added, new requirements of the schema and interface will
                    be discovered frequently.
                </p>

                <p>
                    A semi-automated or fully-automated ingestion pipeline will
                    be key to success. In comparison, Wolfram Language started
                    development over 30 years ago. There is a massive amount of
                    knowledge and it exists in an unstructured form or has a
                    different structure. My hope is that scripts and language
                    model technology can aid in the import of knowledge into the
                    system from sources like Wikipedia, academic papers, open
                    source projects, text books, and more.
                </p>

                <p>
                    Large language models are in some sense type of knowledge
                    engine - just with a different architecture than imagined
                    here. LLMs are neural, stochastic, evolved via gradient
                    descent, tokens in and tokens out. This is a very powerful
                    type of knowledge engine. However, the type of knowledge
                    engine I'm talking about is more classical, built on a
                    relational/graph database, with a query interface. The
                    advantages of the classical type of knowledge engine is
                    efficiency (speed, scale, energy), structure/determinism,
                    and interpretability. The beauty is that both types of
                    knowledge engines compliment one another.
                </p>

                <h4>Knowledge Engines</h4>
                <ul>
                    <li>
                        <a href="https://consensus.app" target="_blank">
                            https://consensus.app
                        </a>
                    </li>
                    <li>
                        <a
                            href="https://www.wolfram.com/language/"
                            target="_blank"
                        >
                            https://www.wolfram.com/language/
                        </a>
                    </li>
                </ul>
            </article>

            <hr />
            <a href="#top">back to top</a>

            <article id="cellular-agriculture">
                <h2>Cellular Agriculture</h2>
                <p>Posted August 12, 2024</p>

                <p>
                    One of the most important topics in the history of human
                    technology.
                </p>

                <blockquote>
                    Cellular agriculture focuses on the production of
                    agricultural products from cell cultures using a combination
                    of biotechnology, tissue engineering, molecular biology, and
                    synthetic biology to create and design new methods of
                    producing proteins, fats, and tissues that would otherwise
                    come from traditional agriculture.[1] Most of the industry
                    is focused on animal products such as meat, milk, and eggs,
                    produced in cell culture rather than raising and
                    slaughtering farmed livestock which is associated with
                    substantial global problems of detrimental environmental
                    impacts (e.g. of meat production), animal welfare, food
                    security and human health.
                </blockquote>
                <p>— <cite>Wikipedia</cite></p>

                <blockquote>
                    Further scaling will require commercial production in
                    significantly larger facilities than what currently exists.
                    Scaling will also require solving an array of complex
                    challenges that will influence the cost of production. These
                    challenges span five key areas: cell lines, cell culture
                    media, bioprocess design, scaffolding, and end product
                    design and characterization.
                </blockquote>
                <p>— <cite>Good Food Institute</cite></p>

                <h3>Resources:</h3>
                <ul>
                    <li>
                        <a
                            href="https://gfi.org/science/the-science-of-cultivated-meat"
                            target="_blank"
                        >
                            https://gfi.org/science/the-science-of-cultivated-meat/
                        </a>
                    </li>
                    <li>
                        <a
                            href="https://en.wikipedia.org/wiki/Cellular_agriculture"
                            target="_blank"
                        >
                            https://en.wikipedia.org/wiki/Cellular_agriculture
                        </a>
                    </li>
                </ul>
            </article>

            <hr />
            <a href="#top">back to top</a>

            <article id="k">
                <h2>k</h2>
                <p>Posted on August 8, 2024</p>

                <h3>Rant</h3>
                <p>
                    Most programming languages drop you off the IO cliff, leave
                    you in the middle of turing complete nowhere, invoice you
                    after "it works on my machine".
                </p>
                <p>
                    We end up installing huge graphs of dependencies, some well
                    maintained, some not, some secure, some vulnerable, some
                    synergize with eachother, many don't.
                </p>
                <p>
                    We end up paying for and fetching against third-party APIs
                    to do things our language cannot do, or there is no open
                    source package for, or our hardware cannot do.
                </p>
                <p>
                    We end up setting up docker stacks, kubernete clusters, "App
                    Platform" stacks, insert orchestration abstraction here,
                    composed of proprietary and open source images that are
                    wired together to have some emergent behavior.
                </p>
                <p>
                    We use postgres or msql because we need persistence, it's
                    too hard to manage a database, so we use managed database
                    service in the cloud, but those managed services have bad DX
                    and are limited so we use PaaS that are wrappers over the
                    same managed service.
                </p>
                <p>
                    We don't test our systems - or orchestrate dependencies,
                    mocks, pipelines, headless browsers wrapped in SaaS
                    products, to give developers who don't test a reason to
                    stick to their ways.
                </p>
                <p>
                    Some language ecosystems are better at X, don't have problem
                    Y, can do Z, can't do V, language U is better than language
                    P for B but not A, good for E but slow for anything else.
                    Language 123 is perfect and solves all problems but won't be
                    1.0 for 10 years. Language AAA solves 90% of all problems,
                    but it doesn't have any open source packages I can leech off
                    of to build an app - and I'll still be fired for using it in
                    production even if it can serve 10 billion hello world
                    requests per second.
                </p>
                <p>
                    We write our code on OS 1 but it doesn't work on OS 2, and
                    we search the internet for wrappers that will port it to
                    mobile, or we'd like to run it on an Arduino that has 2kb of
                    flash memory but a hello world has 4MB runtime overhead.
                </p>

                <h3>The reality</h3>
                <p>
                    Making computers is insaley insanely
                    <em>insanely</em> complicated. Many many
                    <em>many</em> humans are needed to build one like we expect
                    today. Software is also quite complicated. Many
                    <em>many</em> humans are needed to develop the stuff we use
                    today. It is a shock that any of it works at all.
                </p>
                <p>
                    So many humans involved makes things even more complicated.
                    There is intrinsic complexity to computation and engineering
                    - but emergent complexity in so many humans developing the
                    technology in parallel.
                </p>
                <p>
                    Standards and protocols are something we humans developed to
                    wrangle the mess. k is a protocol - a way to talk to
                    computers and for computers to talk to each other.
                </p>

                <h3>The protocol</h3>
                <ul>
                    <li>
                        Humans talk to computers through characters over keys,
                        clicks over buttons, taps over screens, voice over
                        microphone.
                    </li>
                    <li>
                        Computers talk to each other through bits over wire or
                        wave.
                    </li>
                    <li>Computers talk to humans through pixels, audio.</li>
                    <li>
                        Every computer is different. Different hardware,
                        different software, different internal state, different
                        location, different connectivity.
                    </li>
                    <li>
                        Every human is different. Different body, different
                        cognition and behavior, different knowledge, different
                        location, different capability.
                    </li>
                    <li>
                        A computer should be aware of the knowledge,
                        capabilities, and constraints of computers it interacts
                        with.
                    </li>
                    <li>
                        A computer should be aware of the knowledge,
                        capabilities, and constraints of humans it interacts
                        with.
                    </li>
                    <li>
                        A human should be aware of the knowledge, capabilities,
                        and constraints of computers they interact with.
                    </li>
                </ul>
            </article>

            <hr />
            <a href="#top">back to top</a>

            <article id="jsolite">
                <h2>jsolite</h2>
                <p>Posted on August 6, 2024</p>

                <p>javascript object syntax over sqlite</p>
                <a href="https://github.com/kolesparks/jsolite" target="_blank"
                    >GITHUB SOURCE CODE</a
                >

                <p>
                    i've long felt there could be a more idiomatic database for
                    javascript.
                </p>

                <p>
                    i.e. one that feels more like javascript and less an SQL
                    interface
                </p>

                <ul>
                    <li>
                        the bun (<a href="https://bun.sh" target="_blank"
                            >https://bun.sh</a
                        >) runtime has a builtime synchronous sqlite client that
                        is very ergonomic and very performant.
                    </li>
                    <li>
                        The bun client is based on
                        https://www.npmjs.com/package/better-sqlite3 so the hope
                        is that this library can be run on nodejs too by
                        configuring an adapter.
                    </li>
                    <li>
                        the synchronous nature of the sqlite client makes the
                        map and array operations feel like their vanilla js
                        counterpart. no promises/async/await/trycatch.
                    </li>
                    <li>
                        the bun node compatability api does not yet have
                        node:cluster (<a
                            href="https://bun.sh/docs/runtime/nodejs-apis"
                            target="_blank"
                            >https://bun.sh/docs/runtime/nodejs-apis</a
                        >). However, it's in the works
                        <a
                            href="https://github.com/oven-sh/bun/pull/11492"
                            target="_blank"
                            >https://github.com/oven-sh/bun/pull/11492</a
                        >.
                    </li>
                    <li>
                        as an alternative to node:cluster, one can you use
                        bun.spawn and bun.serve({ reusePort: true }) to create
                        multiple bun processes that can handle requests
                        concurrently.
                    </li>
                    <li>
                        sqlite WAL mode allows multiple concurrent readers and
                        the writer does not block the readers.
                    </li>
                    <li>
                        sqlite can be easily backed up and restored because it's
                        a single file (2 files if including the WAL file which
                        is persisted on macos)
                    </li>
                </ul>

                <h4>Questions:</h4>
                <ul>
                    <li>
                        what are the performance/scaling characteristics? So far
                        it seems very good for most low-to-medium scale
                        applications. To help with scaling, it is easy to create
                        table partitions and even database partitions. More on
                        this to come.
                    </li>
                    <li>
                        how to handle the intercept/hooks feature across
                        multiple spawned bun processes? Because the same code is
                        running on each process, the same intercept/hook code
                        will execute. It's that simple.
                    </li>
                    <li>
                        how to achieve zero downtime deployments? I do not think
                        it is possible without the two container versions
                        sharing the same file system. However, I think a couple
                        minutes of downtime is acceptable especially during
                        low-traffic hours. Also, if application code is built
                        ontop a "serverless" runtime, instead of baked into the
                        container image, most deployments won't involve an
                        instance restart/swap. more on this to come.
                    </li>
                </ul>
            </article>

            <hr />
            <a href="#top">back to top</a>

            <article id="tcp-relay-server">
                <h2>TCP Relay Server</h2>
                <p>Posted August 3, 2024</p>

                <p>
                    Just completed the first pass at writing a basic TCP relay
                    server "Written in Rust"™️®. Getting Rust programs to
                    compile has a similar feeling of doing a newspaper sodoku.
                    Its been a good learning experience.
                </p>

                <p>
                    The purpose of this tcp relay server is to eventually act as
                    a relay for replicas in a distributed pubsub cluster.
                    Replicas that receive a message from client A and need to
                    broadcast to client B that is connected to another replica
                    will broadcast the message through the relay.
                </p>

                <p>
                    Without the relay server, the replicas would need to connect
                    to each other directly, which <i>is</i> a possible
                    alternative btw.
                </p>

                <a
                    href="https://gist.github.com/kolesparks/e874c00c8aa9e3f650722f0174de58f6"
                    target="_blank"
                    >Source code</a
                >
            </article>

            <hr />
            <a href="#top">back to top</a>

            <article id="s3-database">
                <h2>S3 as a Database</h2>
                <p>Posted on August 1, 2024.</p>
                <p>
                    Update on August 8, 2024: I'm thinking about
                    <a href="#jsolite">jsolite</a> instead.
                </p>
                <p>
                    Can S3 be used in place of a database? Should S3 be used in
                    place of a database?
                </p>
                <p>
                    I saw a comment on stackoverflow "s3 wasn't designed for
                    that". Perhaps they're right, but this is just an excercise
                    at this point. If it were to work out and actually be good
                    for some situations - then fantastic! If it sucks - then I
                    know more about databases and distributed systems.
                </p>

                <h4>Notes:</h4>
                <ul>
                    <li>
                        Each replica of the s3db server will post a file to s3
                        with it's IP address. Each replica periodically lists
                        the IPs, and inits a tcp connection to any replicas that
                        have a lesser IP than its own. This way all replicas
                        will automatically discover and connect to each other.
                    </li>
                    <li>
                        S3 is strongly consistent but there is no native locking
                        feature, so locking has to be implemented in the s3db
                        server logic. This is probably going to be the greatest
                        source of complexity and latency within the entire
                        system.
                    </li>
                    <li>
                        I have some thoughts on how locking might work, but i'll
                        write more about that later.
                    </li>
                </ul>

                <h4>Resources:</h4>
                <ul>
                    <li>
                        <a
                            href="https://docs.aws.amazon.com/athena/latest/ug/performance-tuning-s3-throttling.html"
                            target="_blank"
                        >
                            https://docs.aws.amazon.com/athena/latest/ug/performance-tuning-s3-throttling.html
                        </a>
                    </li>
                    <li>
                        <a
                            href="https://grisha.org/blog/2013/05/11/relational-database-on-top-of-key-value-store-explained/"
                            target="_blank"
                        >
                            https://grisha.org/blog/2013/05/11/relational-database-on-top-of-key-value-store-explained/
                        </a>
                    </li>
                    <li>
                        <a
                            href="https://en.wikipedia.org/wiki/B%2B_tree"
                            target="_blank"
                        >
                            https://en.wikipedia.org/wiki/B%2B_tree
                        </a>
                    </li>
                </ul>
            </article>

            <hr />
            <a href="#top">back to top</a>

            <article id="thought-diet">
                <h2>Thought Diet</h2>
                <p>Posted on July 31, 2024. Update on August 3, 2024</p>
                <p>
                    Today I'm starting a thought diet. Here are the guidelines:
                </p>
                <ul>
                    <li>
                        I can only think about computer stuff while I'm at the
                        computer (unless I specifically get up from the computer
                        to pace around the room over a problem)
                    </li>
                    <li>
                        Avoid simulating the past, future or possible realities
                    </li>
                    <li>
                        Focus on smells, sounds, tastes, feelings, and entities
                        around me
                    </li>
                </ul>
                <p>I'll keep this page updated (I think) as I go.</p>

                <p>
                    a few days later, i'm doing ok with it. I have violated the
                    first guideline several times. I give myself slack, it's a
                    longterm lifestyle goal, not a fad.
                </p>

                <p>Peace and love,</p>
                <p>Kole</p>
            </article>
        </main>

        <footer>
            <p>You are a good person. Follow your heart.</p>
        </footer>
    </body>
</html>
